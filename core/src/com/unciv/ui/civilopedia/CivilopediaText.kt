package com.unciv.ui.civilopedia

import com.badlogic.gdx.Gdx
import com.badlogic.gdx.graphics.Color
import com.badlogic.gdx.scenes.scene2d.Actor
import com.badlogic.gdx.scenes.scene2d.ui.Skin
import com.badlogic.gdx.scenes.scene2d.ui.Table
import com.badlogic.gdx.utils.Align
import com.unciv.models.ruleset.Ruleset
import com.unciv.models.stats.INamed
import com.unciv.ui.utils.*
import java.io.File
import kotlin.math.max

/** Addon common to most ruleset game objects managing civilopedia display
 *
 * ### Usage:
 * 1. Let [Ruleset] object inherit this
 * 2. Add `"civilopediaText": ["",…],` in the json for these objects
 * 3. Optionally override [getCivilopediaTextHeader] to supply a header line
 * 4. Optionally override [getCivilopediaTextLines] to supply automatic stuff like tech prerequisites, uniques, etc.
 * 4. Optionally override [assembleCivilopediaText] to handle assembly of the final set of lines yourself.
 */
open class CivilopediaText {
    /** List of strings supporting simple [formatting rules][FormattingConstants] that [CivilopediaScreen] can render.
     * May later be merged with automatic lines generated by the deriving class
     *  through overridden [getCivilopediaTextHeader] and/or [getCivilopediaTextLines] methods.
     *
     */
    var civilopediaText = listOf<String>()

    /** Generate header line from object metadata.
     * Default implementation will pull [INamed.name] and render it in 150% normal font size.
     * @return A string conforming to our [formatting rules][FormattingConstants] that will be inserted on top
     */
    open fun getCivilopediaTextHeader(): String? =
        if (this is INamed) "##$name"
        else null

    /** Generate automatic lines from object metadata.
     *
     * Default implementation is empty - no need to call super in overrides.
     *
     * @return A list of strings conforming to our [formatting rules][FormattingConstants] that will be inserted before
     *         the first line of [civilopediaText] beginning with a [link][FormattingConstants]
     */
    open fun getCivilopediaTextLines(): List<String> = listOf()

    /** Override this and return true to tell the Civilopedia that the legacy description is no longer needed */
    open fun replacesCivilopediaDescription() = false
    /** Override this and return true to tell the Civilopedia that this is not empty even if nothing came from json */
    open fun hasCivilopediaTextLines() = false
    /** Indicates that neither json nor getCivilopediaTextLines have content */
    fun isEmpty() = civilopediaText.isEmpty() && !hasCivilopediaTextLines()

    /** Assemble json-supplied lines with automatically generated ones.
     *
     * The default implementation will insert [getCivilopediaTextLines] before the first [linked][FormattingConstants] [civilopediaText] line and [getCivilopediaTextHeader] on top.
     *
     * @return A new CivilopediaText instance containing original [civilopediaText] lines merged with those from [getCivilopediaTextHeader] and [getCivilopediaTextLines] calls.
     */
    open fun assembleCivilopediaText(): CivilopediaText {
        val outerLines = civilopediaText.iterator()
        val newLines = sequence {
            var middleDone = false
            var outerNotEmpty = false
            val header = getCivilopediaTextHeader()
            if (header != null) {
                yield(header)
                yield(FC.separatorSymbol)
            }
            while (outerLines.hasNext()) {
                val next = outerLines.next()
                if (!middleDone && next.isNotEmpty() && (next[0] == FC.linkSymbol || next.hasProtocol())) {
                    middleDone = true
                    if (hasCivilopediaTextLines()) {
                        if (outerNotEmpty) yield("")
                        yieldAll(getCivilopediaTextLines())
                        yield("")
                    }
                }
                outerNotEmpty = true
                yield(next)
            }
            if (!middleDone) {
                if (outerNotEmpty && hasCivilopediaTextLines()) yield("")
                yieldAll(getCivilopediaTextLines())
            }
        }
        val newCivilopediaText = CivilopediaText()
        newCivilopediaText.civilopediaText = newLines.toList()
        return newCivilopediaText
    }

    /** Build a Gdx [Table] showing our [formatted][FormattingConstants] [content][civilopediaText]. */
    fun renderCivilopediaText (skin: Skin, labelWidth: Float, linkAction: ((id: String)->Unit)? = null): Table {
        val table = Table(skin).apply { defaults().pad(2.5f).align(Align.left) }
        for (line in civilopediaText) {
            if (line.isEmpty()) {
                table.add().pad(10f).row()
                continue
            }
            if (line == FC.separatorSymbol) {
                table.addSeparator().pad(5f,0f,15f,0f)
                continue
            }
            val formatting = parseFormatting(line)
            val actor = formatting.render(skin, labelWidth)
            if (formatting.linkTo != null && linkAction != null)
                actor.onClick {
                    linkAction(formatting.linkTo)
                }
            else if (line.hasProtocol())
                actor.onClick {
                    Gdx.net.openURI(line)
                }
            table.add(actor).width(labelWidth).row()
        }
        return table.apply { pack() }
    }
    private fun String.hasProtocol() = startsWith("http://") || startsWith("https://") || startsWith("mailto:")
    private fun String.isHex(start: Int, length: Int) =
        when {
            length == 0 -> false
            start + length > this.length -> false
            substring(start, start + length).all { it.isDigit() || it in 'a'..'f' || it in 'A'..'F' } -> true
            else -> false
        }

    // Tricky: using unicode lookalikes to avoid triggering markdown
    /** ### Formatting rules:
     * A line can start with zero or more of the following formatting instructions, order does not matter:
     *
     * - **[** `category/entryname` **⁆** (pair of square brackets)- create a civilopedia link (max 1 per line). Renders a link icon and a matching object icon if found.
     * - **#** (hash)- Increase header level by 1: applies to font size of whole line - 0 is 100% normal, 1=200%, 2=175%, 3=150%, 4=133%, 5=117%, 6=83%, 7=67%, 8=50%.
     * - **+** `######` (plus followed by a 6-digit hex number) - sets colour of whole line or, if set, the star only.
     * - **✯** (U+272F) - Adds a star icon, optionally coloured
     * - **₋** (underscore) - Make whole line italic (_not implemented_)
     * - **✶** (asterisk) - Make whole line bold (_not implemented_)
     * - **~** (tilde) - Make whole line strikethrough (_not implemented_)
     * - ' ' (space) - Ends formatting explicitly and is not included in the resulting text
     *
     * The first character not matching one of these rules ends formatting, the rest of the string is rendered as text, and goes through translation as is.
     * Icon ordering is always link - object - star.
     * Special case: "---" creates a separator line
     * Special case: lines starting with http://, https:// or mailto: will default to sky-blue and get linked
     */
    object FormattingConstants {            // public only to allow FC typealias
        const val defaultSize = 18
        val headerSizes = arrayOf(18,36,32,27,24,21,15,12,9)    // pretty arbitrary, yes
        val defaultColor: Color = Color.WHITE
        const val linkImage = "OtherIcons/Link"
        const val starImage = "OtherIcons/Star"
        private const val policyIconFolder = "PolicyIcons"
        const val separatorSymbol = "---"
        const val linkSymbol = '['
        const val linkClose = ']'
        const val iconSymbol = '('
        const val iconClose = ')'
        const val headerSymbol = '#'
        const val colorSymbol = '+'
        const val italicSymbol = '_'
        const val boldSymbol = '*'
        const val strikeSymbol = '~'
        const val starredSymbol = '✯'
        const val endFormattingSymbol = ' '
        const val imageSize = 30f

        // todo: CivilopediaScreen itself does something similar
        val categoryToGetIcon = hashMapOf<CivilopediaCategories,(String)->Actor>(
            CivilopediaCategories.Unit to { name -> ImageGetter.getUnitIcon(name, defaultColor) },
            CivilopediaCategories.Building to { name -> ImageGetter.getConstructionImage(name) },
            CivilopediaCategories.Wonder to { name -> ImageGetter.getConstructionImage(name) },
            CivilopediaCategories.Improvement to { name -> ImageGetter.getImprovementIcon(name, imageSize) },
            CivilopediaCategories.Nation to { name -> ImageGetter.getNationIcon(name) },
            CivilopediaCategories.Policy to { name -> ImageGetter.getImage(FC.policyIconFolder + File.separator + name) },
            CivilopediaCategories.Resource to { name -> ImageGetter.getResourceImage(name, imageSize) },
            CivilopediaCategories.Technology to { name -> ImageGetter.getTechIcon(name).apply{ color = defaultColor } },
            CivilopediaCategories.Promotion to { name -> ImageGetter.getPromotionIcon(name, imageSize) },
        )
    }

    private enum class LinkType {None, Internal, External}

    /** Helper class stores the parsing result of [parseFormatting] -
     * line text without [formatting symbols][FormattingConstants] and its discrete formatting info */
    private class CivilopediaFormatting (
            val linkType: LinkType = LinkType.None,
            val linkTo: String? = null,
            val header: Int = 0,
            val color: Color = Color.WHITE,
            val italic: Boolean = false,        // Not implemented
            val bold: Boolean = false,          // Not implemented
            val strike: Boolean = false,        // Not implemented
            val starred: Boolean = false,
            val line: String = ""
        ) {

        fun render(skin: Skin, labelWidth: Float): Actor {
            val fontSize = if (header>= FC.headerSizes.size) FC.defaultSize else FC.headerSizes[header]
            val labelColor = if(starred) FC.defaultColor else color
            val label = if (fontSize == FC.defaultSize && labelColor == FC.defaultColor) line.toLabel()
                else line.toLabel(labelColor,fontSize)
            label.wrap = true
            if (linkType == LinkType.None && !starred)
                return label
            val table = Table(skin)
            var actualWidth = labelWidth
            val imageSize = max(FC.imageSize, fontSize * 1.2f)
            if (linkType != LinkType.None) {
                table.add( ImageGetter.getImage(FC.linkImage) ).size(imageSize)
                actualWidth -= imageSize
            }
            if (linkTo != null) {
                val parts = linkTo.split('/', limit = 2)
                if (parts.size == 2) {
                    val category = CivilopediaCategories.fromLink(parts[0])
                    if (category != null) {
                        val getter = FC.categoryToGetIcon[category]
                        if (getter != null) {
                            val image =
                                getter(parts[1])    // no fail guard because image getters fall back to the white dot when an image is missing?
                            table.add(image).size(imageSize)
                            actualWidth -= imageSize
                        }
                    }
                }
            }
            if (starred) {
                val image = ImageGetter.getImage(FC.starImage)
                image.color = this.color
                table.add(image).size(imageSize)
                actualWidth -= imageSize
            }
            table.add(label).width(actualWidth).padLeft(10f)
            return table
        }
    }

    /** Parse [formatting symbols][FormattingConstants] from a line and store result in a [CivilopediaFormatting] instance. */
    private fun parseFormatting(line: String): CivilopediaFormatting {
        var linkType = LinkType.None
        var linkTo: String? = null
        var header = 0
        var color = FC.defaultColor
        var italic = false
        var bold = false
        var strike = false
        var starred = false

        var i = 0
        while (i < line.length) {
            when (line[i]) {
                FC.linkSymbol -> {
                    val endPos = line.indexOf(FC.linkClose, i+1)
                    if (endPos > i) {
                        linkType = LinkType.Internal
                        linkTo = line.substring(i+1,endPos)
                        i = endPos
                    }
                }
                FC.iconSymbol -> {
                    val endPos = line.indexOf(FC.iconClose, i+1)
                    if (endPos > i) {
                        linkTo = line.substring(i+1,endPos)
                        i = endPos
                    }
                }
                FC.headerSymbol -> header++
                FC.colorSymbol -> {
                    if (line.isHex(i+1,6)) {
                        val hex = line.substring(i+1,i+7)
                        color = Color.valueOf(hex)
                        i += 6
                    } else if (line.isHex(i+1,3)) {
                        val hex = line.substring(i+1,i+4)
                        val hex6 = String(charArrayOf(hex[0], hex[0], hex[1], hex[1], hex[2], hex[2]))
                        color = Color.valueOf(hex6)
                        i += 3
                    }
                }
                FC.italicSymbol -> italic = true
                FC.boldSymbol -> bold = true
                FC.strikeSymbol -> strike = true
                FC.starredSymbol -> starred = true
                FC.endFormattingSymbol -> { i++; break }
                else -> break
            }
            i++
        }

        val text = line.substring(i)
        if (linkType == LinkType.None && text.hasProtocol()) {
            italic = true
            color = Color.SKY
            linkType = LinkType.External
        }

        return CivilopediaFormatting(linkType, linkTo, header, color, italic, bold, strike, starred, text)
    }
}
private typealias FC = CivilopediaText.FormattingConstants

